<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Monitors · CounterTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CounterTools</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Monitors</a><ul class="internal"><li><a class="tocitem" href="#Monitor-API-1"><span>Monitor API</span></a></li><li><a class="tocitem" href="#Monitor-Documentation-1"><span>Monitor Documentation</span></a></li><li><a class="tocitem" href="#Select-Registers-1"><span>Select Registers</span></a></li></ul></li><li><a class="tocitem" href="../records/">Record</a></li><li><a class="tocitem" href="../counters/">Counter Resources</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../core/example/">Core Monitoring Example</a></li><li><a class="tocitem" href="../uncore/imc/">Integrated Memory Controller (iMC) Monitoring Example</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Monitors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Monitors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hildebrandmw/CounterTools.jl/blob/master/docs/src/monitors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Monitors-1"><a class="docs-heading-anchor" href="#Monitors-1">Monitors</a><a class="docs-heading-anchor-permalink" href="#Monitors-1" title="Permalink"></a></h1><p>The process of setting up and reading from various performance montoring counters is delegated to various <code>Monitor</code> types. These monitors are:</p><ul><li><a href="#CounterTools.CoreMonitor"><code>CounterTools.CoreMonitor</code></a>: Collects Core level counters.</li></ul><p>These counters work on a CPU level granularity and can capture information such as number of retiretired instructions, number of floating point instrucitons, L1/L2 accesses etc.</p><ul><li><a href="#CounterTools.IMCMonitor"><code>CounterTools.IMCMonitor</code></a>: Manages counters on the Integrated Memory Controller (iMC).</li></ul><p>This can record events such as number of DRAM reads and writes.</p><ul><li><a href="#CounterTools.CHAMonitor"><code>CounterTools.CHAMonitor</code></a>: Manages counters for the Caching Home Agents (CHA) in the system.</li></ul><p>This can record events such as number of L3 hits and misses.</p><h2 id="Monitor-API-1"><a class="docs-heading-anchor" href="#Monitor-API-1">Monitor API</a><a class="docs-heading-anchor-permalink" href="#Monitor-API-1" title="Permalink"></a></h2><p>After creations, all monitors have the same simple API. The most common method will be <a href="#Base.read-Tuple{CounterTools.AbstractMonitor}"><code>read</code></a>, which will read from all of the PMUs currently controlled by the monitor and return the raw counters values in a <a href="../records/#CounterTools.Record"><code>CounterTools.Record</code></a>. See the <a href="../records/#CounterTools.Record"><code>CounterTools.Record</code></a> documentation for details on working with that data structure.</p><p>Two additional methods specified by each Monitor are <a href="#CounterTools.program!"><code>CounterTools.program!</code></a> and <a href="#CounterTools.reset!"><code>CounterTools.reset!</code></a>. These methods configure the PMUs and reset the PMUs to their default state respectively. Normally, you will not have to call these methods directly since programming is usually done during monitor creation and <a href="#CounterTools.reset!"><code>CounterTools.reset!</code></a> is automatically called when the Monitor is garbage collected.</p><p>A simple usage of this would look like:</p><pre><code class="language-julia">monitor = # create monitor

# Read once from the counters
first = read(monitor)

# Read again from the coutners
second = read(monitor)

# Automatically compute the counter deltas
deltas = second - first

# Aggregate all deltas
CounterTools.aggregate(deltas)</code></pre><p>Additionally, if you are working with multiple samples, the following can serve as a template for your code.</p><pre><code class="language-none">monitor = # create monitor
data = map(1:10) do i
    sleep(0.1)
    read(monitor)
end

# `data` is a `Vector{&lt;:Record}`
# To compute the counter difference across all samples, we can call Julia&#39;s `diff` function:
deltas = diff(data)

# Finally, we can aggregate each diff.
CounterTools.aggregate.(deltas)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Raw counter values will be wrapped in a <a href="../records/#CounterTools.CounterValue"><code>CounterTools.CounterValue</code></a> type that will automatically detect and correct for counter overflow when subtracting counter values.</p></div></div><h2 id="Monitor-Documentation-1"><a class="docs-heading-anchor" href="#Monitor-Documentation-1">Monitor Documentation</a><a class="docs-heading-anchor-permalink" href="#Monitor-Documentation-1" title="Permalink"></a></h2><h3 id="Monitors-2"><a class="docs-heading-anchor" href="#Monitors-2">Monitors</a><a class="docs-heading-anchor-permalink" href="#Monitors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CounterTools.CoreMonitor" href="#CounterTools.CoreMonitor"><code>CounterTools.CoreMonitor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoreMonitor(events, cpus; program = true)</code></pre><p>Construct a <code>CoreMonitor</code> monitoring <code>events</code> on <code>cpus</code>. Arguments <code>events</code> should be a <code>Tuple</code> of <a href="#CounterTools.CoreSelectRegister"><code>CounterTools.CoreSelectRegister</code></a> and <code>cpus</code> is any iterable collection of CPU indices.</p><p>If <code>program == true</code>, then also program the performance counters to on each CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/core/core.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.IMCMonitor" href="#CounterTools.IMCMonitor"><code>CounterTools.IMCMonitor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IMCMonitor(events, socket; [program = true, finalize = true])</code></pre><p>Monitor the Integrated Memory Controller (IMC) for <code>events</code> on a <strong>single</strong> selected CPU <code>socket</code>. This can gather information such as number of DRAM read and write operations.  Argument <code>event</code> should be a <code>Tuple</code> of <a href="#CounterTools.UncoreSelectRegister"><code>CounterTools.UncoreSelectRegister</code></a> and <code>socket</code> should be either an <code>Integer</code> or <code>IndexZero</code>.</p><p>If <code>finalize = true</code> is passed, a finalizer will be attached to the <code>IMCMonitor</code> to clean up the hardware counter&#39;s state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/uncore/imc.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.CHAMonitor" href="#CounterTools.CHAMonitor"><code>CounterTools.CHAMonitor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CHAMonitor(events, socket, cpu; [program = true], [filter0], [filter1])</code></pre><p>Monitor the Caching Home Agent counters for <code>events</code> on a <strong>single</strong> selected CPU <code>socket</code>. This can gather information such as number of L3 hits and misses. Argument <code>event</code> should be a <code>Tuple</code> of <a href="#CounterTools.UncoreSelectRegister"><code>CounterTools.UncoreSelectRegister</code></a> and <code>socket</code> should be either an <code>Integer</code> or <code>IndexZero</code>. Further, <code>cpu</code> is the CPU that will be actually reading the counters. For best performance, <code>cpu</code> should be located on <code>socket</code>.</p><p><strong>Filters</strong></p><p>The CHA Performance Monitoring Units allow counters to be filtered in various ways such as issuing Core or Thread ID, request opcode etc.</p><p>These can be passed via the <code>filter0</code> and <code>filter1</code> keyword arguments and correspond to the CHA filters 0 and 1 repectively.</p><p>Note: <code>filter0</code> should be a <a href="#CounterTools.CHAFilter0"><code>CounterTools.CHAFilter0</code></a> and <code>filter1</code> should be a <a href="#CounterTools.CHAFilter1"><code>CounterTools.CHAFilter1</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/uncore/cha.jl#L17-L38">source</a></section></article><h3 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{CounterTools.AbstractMonitor}" href="#Base.read-Tuple{CounterTools.AbstractMonitor}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read(monitor) -&gt; Record</code></pre><p>Read from all counters currently managed by <code>monitor</code> and return the results as a <a href="../records/#CounterTools.Record"><code>CounterTools.Record</code></a>.  The structure of the <a href="../records/#CounterTools.Record"><code>CounterTools.Record</code></a> usually reflects the hierarchical structure of the counters being monitored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/CounterTools.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.program!" href="#CounterTools.program!"><code>CounterTools.program!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">program!(monitor)</code></pre><p>Program the PMUs managed by <code>monitor</code>. This must be called before any results returned from <code>read</code> will be meaningful.</p><p>This method is called automatically when <code>monitor</code> was created unless the <code>program = false</code> keyword was passed the monitor contructor function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/CounterTools.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.reset!" href="#CounterTools.reset!"><code>CounterTools.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset!(monitor)</code></pre><p>Set the PMUs managed by <code>monitor</code> back to their original state.</p><p>This method is called automatically when <code>monitor</code> is garbage collected unless the <code>reset = false</code> keyword is passed to the monitor constructor function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/CounterTools.jl#L32-L39">source</a></section></article><h2 id="Select-Registers-1"><a class="docs-heading-anchor" href="#Select-Registers-1">Select Registers</a><a class="docs-heading-anchor-permalink" href="#Select-Registers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CounterTools.CoreSelectRegister" href="#CounterTools.CoreSelectRegister"><code>CounterTools.CoreSelectRegister</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoreSelectRegister(; kw...)</code></pre><p>Construct a bitmask for programming <code>Core</code> level counters.</p><p><strong>Keywords</strong></p><ul><li><p><code>event::UInt</code>: Select the event to be counted. Default: <code>0x00</code></p></li><li><p><code>umask::Uint</code>: Select the subevent to be counted within the selected event. Default: <code>0x00</code></p></li><li><p><code>usr::Bool</code>: Specifies the counter should be active when the processor is operating at   privilege modes 1, 2, and 3. Default: <code>true</code>.</p></li><li><p><code>os::Bool</code>: Specifies the counter should be active when the processor is operating at   privilege mode 0. Default: <code>true</code>.</p></li><li><p><code>e::Bool</code>: Edge detect. Default: <code>false</code>.</p></li><li><p><code>en::Bool</code>: Enable the counter. Default: <code>true</code>.</p></li><li><p><code>inv::Bool</code>: When set, inverts the counter-mask (CMASK) comparison, so that both greater   than or equal to and less than comparisons can be made (0: greater than or equal; 1:   less than). Note if counter-mask is programmed to zero, INV flag is ignored. Default: <code>false</code>.</p></li><li><p><code>cmask::Bool</code>: When this field is not zero, a logical processor compares this mask to the   events count of the detected microarchitectural condition during a single cycle. If the   event count is greater than or equal to this mask, the counter is incremented by one.   Otherwise the counter is not incremented.</p><p>This mask is intended for software to characterize microarchitectural conditions that   can count multiple occurrences per cycle (for example, two or more instructions retired   per clock; or bus queue occupations). If the counter-mask field is 0, then the counter   is incremented each cycle by the event count associated with multiple occurrences.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/bitfield.jl#L52-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.UncoreSelectRegister" href="#CounterTools.UncoreSelectRegister"><code>CounterTools.UncoreSelectRegister</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UncoreSelectRegister(; kw...)</code></pre><p>Construct a bitmask for programming <code>Uncore</code> level counters.</p><p><strong>Keywords</strong></p><ul><li><p><code>event::UInt</code>: Select event to be counted. Default: <code>0x00</code></p></li><li><p><code>umask::UInt</code>: Select subevents to be counted within the selected event. Default: <code>0x00</code></p></li><li><p><code>reset::Bool</code>: When set to 1, the corresponding counter will be cleared to 0. Default: <code>false</code></p></li><li><p><code>edge_detact::Bool</code>: When set to 1, rather than measuring the event in each cycle it is   active, the corresponding counter will increment when a 0 to 1 transition (i.e. rising edge)   is detected.</p><p>When 0, the counter will increment in each cycle that the event is asserted.</p><p>NOTE: <code>edge_detect</code> is in series following <code>thresh</code>, Due to this, the <code>thresh</code> field   must be set to a non-0 value. For events that increment by no more than 1 per cycle,   set <code>thresh</code> to 0x1. Default: <code>false</code>.</p></li><li><p><code>overflow_enable::Bool</code>: When this bit is set to 1 and the corresponding counter overflows,   an overflow message is sent to the UBox’s global logic. The message identifies the unit   that sent it. Default: <code>false</code>.</p></li><li><p><code>en::Bool</code>: Local Counter Enable. Default: <code>true</code>.</p></li><li><p><code>invert::Bool</code>: Invert comparison against Threshold.</p><p>0 - comparison will be ‘is event increment &gt;= threshold?’.</p><p>1 - comparison is inverted - ‘is event increment &lt; threshold?’</p><p>e.g. for a 64-entry queue, if SW wanted to know how many cycles the queue had fewer   than 4 entries, SW should set the threshold to 4 and set the invert bit to 1.   Default: <code>false</code>.</p></li><li><p><code>thresh::UInt</code>: Threshold is used, along with the invert bit, to compare against the   counter’s incoming increment value. i.e. the value that will be added to the counter.</p><p>For events that increment by more than 1 per cycle, if the threshold is set to a value   greater than 1, the data register will accumulate instances in which the event   increment is &gt;= threshold. Default: <code>0x00</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/bitfield.jl#L103-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.CHAFilter0" href="#CounterTools.CHAFilter0"><code>CounterTools.CHAFilter0</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CHAFilter0(; kw...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/bitfield.jl#L165-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CounterTools.CHAFilter1" href="#CounterTools.CHAFilter1"><code>CounterTools.CHAFilter1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CHAFilter1(; kw...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hildebrandmw/CounterTools.jl/blob/844d20c3541a5ec975a9a9fa77c5ed9e9d131bba/src/bitfield.jl#L193-L195">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting Started</a><a class="docs-footer-nextpage" href="../records/">Record »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 August 2020 23:10">Sunday 2 August 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
