<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>iMC · CounterTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CounterTools</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><a class="tocitem" href="../core/">Core Monitoring</a></li><li><span class="tocitem">Uncore Monitoring</span><ul><li class="is-active"><a class="tocitem" href>iMC</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Uncore Monitoring</a></li><li class="is-active"><a href>iMC</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>iMC</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hildebrandmw/CounterTools.jl/blob/master/docs/src/imc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrated-Memory-Controller-(iMC)-Monitoring-1"><a class="docs-heading-anchor" href="#Integrated-Memory-Controller-(iMC)-Monitoring-1">Integrated Memory Controller (iMC) Monitoring</a><a class="docs-heading-anchor-permalink" href="#Integrated-Memory-Controller-(iMC)-Monitoring-1" title="Permalink"></a></h1><p>CounterTools allows for programming and reading from the performance counters within the iMC. This is primarily done through the <a href="@ref"><code>CounterTools.IMCMonitor</code></a> data type. We&#39;ll provide a quick usage summary below for those just looking to get started, and then include some more details later.</p><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>For this example, we will show how to monitor DRAM read and write bandwidth on a 2-socket Cascade Lake Xeon server. Before we get started, we need to know the <code>event</code> and <code>umask</code> codes for these events. For the CLX microarchitecture, this can be found at the following link: <a href="https://download.01.org/perfmon/CLX/">https://download.01.org/perfmon/CLX/</a> (look in the <code>uncore</code> JSON file). We are looking for the events <code>&quot;UNC_M_CAS_COUNT.RD</code> and <code>UNC_M_CAS_COUNT.WR</code>, both with event number <code>0x3</code> and umasks <code>0x3</code> and <code>0xC</code> respectively. These counters record the number of read or write actions performed by the memory controller, where each action involves 64 Bytes of data. Thus, to get the actual bandwidth, you must multiply whatever count number you get by 64.</p><p>Lets get started.</p><p>First, start up a Julia session. For the purposes of this demo, we will use <code>numactl</code> to constrain Julia to NUMA node 0 - just to make sure that we&#39;re recording the correct information.</p><pre><code class="language-sh">sudo numactl --cpunodebind=0 --membind=0 &lt;path/to/julia&gt;</code></pre><p>Now, within Julia, we start the <code>CounterTools</code> package and set-up our events</p><pre><code class="language-julia">using CounterTools
events = (
    CounterTools.UncoreSelectRegister(; event = 0x4, umask = 0x3),
    CounterTools.UncoreSelectRegister(; event = 0x4, umask = 0xC),
)</code></pre><p>Observe that we&#39;re now using <a href="@ref"><code>CounterTools.UncoreSelectRegisters</code></a> instead of <a href="@ref"><code>CounterTools.CoreSelectRegisters</code></a>. This is because the bit fields of the Uncore selection registers are slightly different than the Core selection registers. Note that construction of a <a href="@ref"><code>IMCMonitor</code></a> <strong>requires</strong> <code>CounterTools.UncoreSelectRegisters</code>.</p><p>With that, lets instantiate a <code>IMCMonitor</code>!</p><pre><code class="language-julia">monitor = CounterTools.IMCMonitor(events)</code></pre><p>This automates the process of programming and starting the iMC performance counters. We can now collect data from the counters:</p><pre><code class="language-julia">data = read(monitor)
display(data)</code></pre><p><strong>WHOA</strong>: What the heck is going on?? What is returned by reading data is a somewhat gnarly nested <code>Tuple</code>, but there is a method to this madness. I&#39;m running this on a 2-socket system, so we have performance counter data for each socket. This is the <strong>outermost</strong> tuple of the returned data.</p><pre><code class="language-julia"># Performance Counters for Socket 0
data[1]
# Performance Counters for Socket 1
data[2]</code></pre><p>Next, each socket has two memory controllers. This is the next level of hierarchy:</p><pre><code class="language-julia"># Socket 0, iMC 0
data[1][1]
# Socket 0, iMC 1
data[1][2]</code></pre><p>Each iMC has 3 channels. This is the <strong>next</strong> level of hierarchy:</p><pre><code class="language-julia"># Socket 0, iMC 0, Channel 0
data[1][1][1]
# Socket 0, iMC 0, Channel 1
data[1][1][2]
# Socket 0, iMC 0, Channel 2
data[1][1][3]</code></pre><p>Finally, each iMC channel has 4 programmable counters. This is the <strong>last</strong> level of hierarchy, represented as a 4-tuple of <a href="@ref"><code>CounterValue</code></a>s The counter values in this last tuple correspond elementwise to the original events used to construct the <code>IMCMonitor</code>. So, <code>data[1][1][1][1]</code> is the <strong>counter value</strong> of DRAM reads for channel 0, iMC 0, Socket 0. Similarly, <code>data[1][1][1][2]</code> is the value for DRAM writes. Since we didn&#39;t program counters 2 or 3 (speaking in index zero terms), those values are simply 0.</p><p>Now, this can be a lot to take in. Fortunately, we have some helpful tool! First, remember that we generally look for a <strong>difference</strong> between subsequent samples. Here&#39;s an example of using some of the tools to make that happen:</p><pre><code class="language-julia"># Create a largish array. Precompile &quot;sum&quot; function
A = rand(Float64, 10^7); sum(A);

# Sample counters before and after performing an operation that reads the array
pre = read(monitor);
sum(A);
post = read(monitor);

# Now, we aggregate counters across sockets
aggregate = CounterTools.aggregate.(CounterTools.counterdiff(post, pre))
# (
#    (1474725, 118291, 0, 0),   # &lt;- Aggregate for Socket 0
#    (136433, 113153, 0, 0)     # &lt;- Aggregate for Socket 1
# )</code></pre><p>Wow! That&#39;s much cleaner. This helpful command essentially adds the counter values for all the channels across each socket and returns the sum. We observe that Socket 0 (the one we&#39;re running Julia on) has a large number of reads (the first entry in the Tuple) Lets calculate the corresponding number of bytes read</p><pre><code class="language-julia">bytes_read = aggregate[1][1] * 64
# 94382400

sizeof(A)
# 80000000</code></pre><p>We see a nice correlation here between the monitored number of bytes read and the number of bytes we&#39;d expect to see! Note that there is more traffic on the system than just the reading of the array. For example, other processes on the system are generating DRAM traffic. Plus, our own process is doing things like reading code from DRAM.</p><p><strong>NOTE</strong>: Summing across all channels is not always what you want to do. It&#39;s easy to make changes. If, for example, you want to take the maximum across each channel (I&#39;m not sure at the moment why you&#39;d want to, but lets say that you do). It&#39;s as simple as</p><pre><code class="language-julia">CounterTools.aggregate(max, CounterTools.counterdiff(post, pre))
# ((247148, 20058, 0, 0), (23139, 19558, 0, 0))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core/">« Core Monitoring</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 March 2020 00:40">Wednesday 18 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
