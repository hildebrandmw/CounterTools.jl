<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrated Memory Controller (iMC) Monitoring Example · CounterTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CounterTools</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../monitors/">Monitors</a></li><li><a class="tocitem" href="../../records/">Record</a></li><li><a class="tocitem" href="../../counters/">Counter Resources</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../core/example/">Core Monitoring Example</a></li><li class="is-active"><a class="tocitem" href>Integrated Memory Controller (iMC) Monitoring Example</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Integrated Memory Controller (iMC) Monitoring Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrated Memory Controller (iMC) Monitoring Example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hildebrandmw/CounterTools.jl/blob/master/docs/src/uncore/imc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrated-Memory-Controller-(iMC)-Monitoring-Example-1"><a class="docs-heading-anchor" href="#Integrated-Memory-Controller-(iMC)-Monitoring-Example-1">Integrated Memory Controller (iMC) Monitoring Example</a><a class="docs-heading-anchor-permalink" href="#Integrated-Memory-Controller-(iMC)-Monitoring-Example-1" title="Permalink"></a></h1><p>CounterTools allows for programming and reading from the performance counters within the iMC. This is primarily done through the <a href="../../monitors/#CounterTools.IMCMonitor"><code>CounterTools.IMCMonitor</code></a> data type. We&#39;ll provide a quick usage summary below for those just looking to get started, and then include some more details later.</p><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>For this example, we will show how to monitor DRAM read and write bandwidth on a 2-socket Cascade Lake Xeon server. Before we get started, we need to know the <code>event</code> and <code>umask</code> codes for these events. For the CLX microarchitecture, this can be found at the following link: <a href="https://download.01.org/perfmon/CLX/">https://download.01.org/perfmon/CLX/</a> (look in the <code>uncore</code> JSON file). We are looking for the events <code>&quot;UNC_M_CAS_COUNT.RD</code> and <code>UNC_M_CAS_COUNT.WR</code>, both with event number <code>0x3</code> and umasks <code>0x3</code> and <code>0xC</code> respectively. These counters record the number of read or write actions performed by the memory controller, where each action involves 64 Bytes of data. Thus, to get the actual bandwidth, you must multiply whatever count number you get by 64.</p><p>Lets get started.</p><p>First, start up a Julia session. For the purposes of this demo, we will use <code>numactl</code> to constrain Julia to NUMA node 0 - just to make sure that we&#39;re recording the correct information.</p><pre><code class="language-sh">sudo numactl --cpunodebind=0 --membind=0 &lt;path/to/julia&gt;</code></pre><p>Now, within Julia, we start the <code>CounterTools</code> package and set-up our events</p><pre><code class="language-julia">using CounterTools
events = (
    CounterTools.UncoreSelectRegister(; event = 0x4, umask = 0x3),
    CounterTools.UncoreSelectRegister(; event = 0x4, umask = 0xC),
)</code></pre><p>Observe that we&#39;re now using <a href="../../monitors/#CounterTools.UncoreSelectRegister"><code>CounterTools.UncoreSelectRegister</code></a> instead of <a href="../../monitors/#CounterTools.CoreSelectRegister"><code>CounterTools.CoreSelectRegister</code></a>. This is because the bit fields of the Uncore selection registers are slightly different than the Core selection registers. Note that construction of a <a href="../../monitors/#CounterTools.IMCMonitor"><code>CounterTools.IMCMonitor</code></a> <strong>requires</strong> <code>CounterTools.UncoreSelectRegisters</code>.</p><p>With that, lets instantiate a <a href="../../monitors/#CounterTools.IMCMonitor"><code>CounterTools.IMCMonitor</code></a>! Note that we have to pass which socket we want to monitor. Since we&#39;ve restricted Julia to running on socket 0 using <code>numactl</code>, this is the socket we pass to <code>IMCMonitor</code>. We wrap it in a <a href="../../#CounterTools.IndexZero"><code>CounterTools.IndexZero</code></a> to indicate that we really do want a literal 0. We could have just as easily passed the integer <code>1</code> to achieve the same result.</p><pre><code class="language-julia">monitor = CounterTools.IMCMonitor(events, CounterTools.IndexZero(0))</code></pre><p>This automates the process of programming and starting the iMC performance counters. We can now collect data from the counters:</p><pre><code class="language-julia">data = read(monitor)
display(data)

# Socket Record with 2 entries:
#    Imc Record with 3 entries:
#       Channel Record with 4 entries:
#          CounterTools.CounterValue
#
# Socket:
#    Imc:
#       Channel: (CV(873907), CV(437771), CV(0), CV(0))
#       Channel: (CV(877335), CV(438516), CV(0), CV(0))
#       Channel: (CV(872746), CV(438298), CV(0), CV(0))
#    Imc:
#       Channel: (CV(865708), CV(432371), CV(0), CV(0))
#       Channel: (CV(866270), CV(430789), CV(0), CV(0))
#       Channel: (CV(867648), CV(431401), CV(0), CV(0))</code></pre><p>Lets tease out what&#39;s going on here. The top level is a <code>Record{:socket}</code>, which contains the counter results for our socket of interest. Each socket has two Integrated Memory Controllers, which are modeled by the <code>Record{:imc}</code> inside the outermost record. Furthermore, each IMC has three Channels, which are the three <code>Record{:channel}</code> inside each IMC. Finally, each channel has four counters, which correspond to the entries in the <code>Record{:channel}</code>.</p><p>Now, this can be a lot to take in. Fortunately, we have some helpful tool! First, remember that we generally look for a <strong>difference</strong> between subsequent samples. Here&#39;s an example of using some of the tools to make that happen:</p><pre><code class="language-julia"># Create a largish array. Precompile &quot;sum&quot; function
A = rand(Float64, 10^7); sum(A);

# Sample counters before and after performing an operation that reads the array
pre = read(monitor);
sum(A);
post = read(monitor);

# Now, we aggregate counters across sockets
aggregate = CounterTools.aggregate(post - pre)
# (1491562, 250617, 0, 0)</code></pre><p>Wow! That&#39;s much cleaner. This helpful command essentially adds the counter values for all the channels across each socket and returns the sum. We observe that Socket 0 (the one we&#39;re running Julia on) has a large number of reads (the first entry in the Tuple) Lets calculate the corresponding number of bytes read</p><pre><code class="language-julia">bytes_read = aggregate[1] * 64
# 95459968

sizeof(A)
# 80000000</code></pre><p>We see a nice correlation here between the monitored number of bytes read and the number of bytes we&#39;d expect to see! Note that there is more traffic on the system than just the reading of the array. For example, other processes on the system are generating DRAM traffic. Plus, our own process is doing things like reading code from DRAM.</p><p><strong>NOTE</strong>: Summing across all channels is not always what you want to do. It&#39;s easy to make changes. If, for example, you want to take the maximum across each channel (I&#39;m not sure at the moment why you&#39;d want to, but lets say that you do). It&#39;s as simple as</p><pre><code class="language-julia">CounterTools.aggregate(max, post - pre)
# (252053, 42442, 0, 0)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../core/example/">« Core Monitoring Example</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 June 2020 20:59">Tuesday 23 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
