<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Monitoring · CounterTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CounterTools</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Core Monitoring</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li></ul></li><li><span class="tocitem">Uncore Monitoring</span><ul><li><a class="tocitem" href="../imc/">iMC</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Core Monitoring</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Monitoring</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hildebrandmw/CounterTools.jl/blob/master/docs/src/core.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-1"><a class="docs-heading-anchor" href="#Usage-1">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-1" title="Permalink"></a></h1><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>Suppose we wanted to measure the number of floating point instructions executed by Julia&#39;s BLAS library for a matrix multiply. Note - right off the bat, we don&#39;t know for sure which class of AVX instructions the pre-built BLAS libraries use (i.e. 128, 256, or 512 bit)</p><p>First, we start Julia under <code>numactl</code>. I&#39;m running on a system with 2 sockets, each socket has 24 physical CPUs, 48 hyperthreaded logical CPUs. A note on numbering:</p><ul><li>CPU numbers 0 to 23 represent distinct physical cores on socket 0.</li><li>CPU numbers 24-47 represent distinct physical cores on socket 1.</li><li>CPU numbers 48-71 represent hyperthreaded cores on socket 0.   That is, CPU 48 and CPU 0 refer to the SAME physical CPU, but different hyper threads.</li><li>CPU numbers 72-95 are hyperthreaded cores on socket 1.</li></ul><p>By default, Julia uses 8 threads for its BLAS library, so the start command is</p><pre><code class="language-none">sudo numactl --physcpubind=24-31 --membind=1 &lt;path/to/julia&gt;</code></pre><p>Now, in Julia:</p><pre><code class="language-julia">using CounterTools

# Select the Events we wish to monitor.
# Event numbers and umasks can be found at:
#   https://download.01.org/perfmon
#
# I&#39;m running this on a Cascade Lake processor, so I&#39;m using the CLX collection
# of counter values.
#
# Since we don&#39;t know (yet) what instructions are used by Julia&#39;s BLAS library, we
# include events for
#
#   - Scalar Floating Point
#   - 128b packed
#   - 256b packed
#   - 512b packed
#
# NOTE: Since hyper threading is enabled, we only have 4 programmable counters available
# for use.
# Trying to use more will generate an error.
events = (
    CounterTools.CoreSelectRegister(event = 0xC7, umask = 0x01),   # scalar
    CounterTools.CoreSelectRegister(event = 0xC7, umask = 0x04),   # 128b
    CounterTools.CoreSelectRegister(event = 0xC7, umask = 0x10),   # 256b
    CounterTools.CoreSelectRegister(event = 0xC7, umask = 0x40),   # 512b
)

# Next, we initialize our arrays and force JIT compilation of the code
A = rand(Float64, 5000, 5000)
B = rand(Float64, 5000, 5000)
A * B

# Now, initialize a CoreMonitor to watch core-level counters
#
# This will program the CPU&#39;s counters and begin running.
#
# Since we&#39;ve restricted the number of CPUs using `numactl`, we choose to only monitor
# that subset of CPUs
#
# Note that since Julia is Index 1, the CPU range is 25:32 instead of 24:31.
monitor = CounterTools.CoreMonitor(25:32, events)

# We can read the current values from the monitor using `read`:
read(monitor)

# Note that the elements of the result are of type `CounterTools.CoreCounterValue`
# This is because the counter registers on the CPU are 48-bits wide and thus are
# likely to overflow at some point.
#
# The type `CounterTools.CoreCounterValue` implements a little extra functionality that
# detects when overlap occurs and automatically corrects for it.
#
# Since counters just collect raw counts, this allows for a stream of raw counter values
# to be collected and then differences to be taken to obtain deltas.

# Now we actually do some monitoring
pre = read(monitor)
A * B
post = read(monitor)
deltas = map((x, y) -&gt; x .- y, post, pre)

display(deltas)
# 8-element Array{NTuple{4,Int64},1}:
#  (0, 0, 7615200000, 0)
#  (0, 0, 7314600000, 0)
#  (0, 0, 8016000000, 0)
#  (0, 0, 8016000000, 0)
#  (0, 0, 8016000000, 0)
#  (0, 0, 8016000000, 0)
#  (0, 0, 7615200000, 0)
#  (4529, 0, 8016000000, 0)</code></pre><h3 id="Discussion-of-Results-1"><a class="docs-heading-anchor" href="#Discussion-of-Results-1">Discussion of Results</a><a class="docs-heading-anchor-permalink" href="#Discussion-of-Results-1" title="Permalink"></a></h3><p>Lets break down what the results mean. First, each entry in the outer array represents the counter results for one CPU in the CPUs we were gathering metrics on. That is, the first entry is CPU 24, the second is CPU 25 etc. The entries themselves correspond to counter deltas for each counter in <code>events</code>. Thus, the first entry is for scalar double-precision floating point operations, the second is for 128b, the third is for 256b, and the fourth is 512b. We observe that JULIA&#39;s blas library must use AVX-256 instructions.</p><p>Now, does the count make sense? Well, lets count up the total number of operations:</p><pre><code class="language-julia">total_avx_256 = sum(x -&gt; x[3], deltas)

# Multiply by 4 because each AVX-256 instruction operates on 4 Float64s.
display(4 * total_avx_256)
# 250500000000</code></pre><p>Now, we approximate the total number of expected operations on the 5000x5000 matrices.</p><pre><code class="language-none">total_expected = 5000^3 * 2
display(total_expected)
# 250000000000</code></pre><p>Note that we multiply by 2 because the multiply-add required for matrix multiplication counts as 2 operations.</p><p>We see that the numbers line up pretty well!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting Started</a><a class="docs-footer-nextpage" href="../imc/">iMC »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 March 2020 00:40">Wednesday 18 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
